# -*- coding: utf-8 -*-
"""MC1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hbga1_LX4-c6E3ray_PtL0p3AJqY045S
"""

### 2.1 Monte Carlo Integration

import numpy as np

def monte_carlo_integration(func, num_samples):
    total = 0
    for i in range(num_samples):
        # Generate random samples within [0, 1]
        samples = np.random.rand(6)

        # Calculate the function value at the samples
        f = func(*samples)

        # Accumulate the function values
        total += f

    # Calculate the average of the accumulated function values
    average = total / num_samples

    # Calculate the volume of the integration domain
    volume = 1 ** 6  # Integration domain: [0, 1]^6

    # Estimate the integral value
    integral = average * volume

    return integral

def function(x1, x2, x3, x4, x5, x6):
    return np.sin(np.pi/2 * np.exp((x1+x2+x3)/3) * np.exp((x4+x5+x6)/3))

# Sample size for Monte Carlo integration
num_samples = 1000000

estimated_integral = monte_carlo_integration(function, num_samples)

print("Estimated integral value:", estimated_integral)

### 2.2 Different Sample Sizes

import numpy as np
import matplotlib.pyplot as plt

def monte_carlo_integration(func, num_samples):
    total = 0
    for _ in range(num_samples):
        samples = np.random.rand(6)
        f = func(*samples)
        total += f

    average = total / num_samples
    volume = 1 ** 6
    integral = average * volume

    return integral

def function(x1, x2, x3, x4, x5, x6):
    return np.sin(np.pi/2 * np.exp((x1+x2+x3)/3) * np.exp((x4+x5+x6)/3))

# Different sample sizes
sample_sizes = [20, 50, 100, 500, 1000, 10000, 30000, 70000, 100000, 200000, 400000, 550000, 700000, 850000, 1000000, 1100000, 1200000, 1500000]

# Store the estimated integral values
estimated_integrals = []

for num_samples in sample_sizes:
    estimated_integral = monte_carlo_integration(function, num_samples)
    estimated_integrals.append(estimated_integral)

# Plot the results

plt.plot(sample_sizes, estimated_integrals, marker='o')
plt.xlabel('Sample Size')
plt.ylabel('Estimated Integral Value')
plt.title('Monte Carlo Integration: Estimated Integral vs Sample Size')
plt.grid(True)
plt.show()

### 2.3 Variance Reduction Technique

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import qmc

def monte_carlo_integration(func, samples, sequence = 'random'):
    total = 0
    num_samples = samples.shape[0]

    for i in range(num_samples):

        sample = samples[i, :]
        f = func(*sample)
        total += f

    average = total / num_samples
    volume = 1 ** 6
    integral = average * volume

    return integral

def function(x1, x2, x3, x4, x5, x6):
    return np.sin(np.pi/2 * np.exp((x1+x2+x3)/3) * np.exp((x4+x5+x6)/3))

# The balance properties of Sobol' points require n to be a power of 2
sample_sizes = [32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768]

# Store the estimated integral values for random sequence
estimated_integrals_random = []

# For Halton sequence
estimated_integrals_halton = []

# For Latin Hypercube Sampling (LHS)
estimated_integrals_lhs = []

# Perform the experiment for different sample sizes using random, Halton, and LHS sequences
for num_samples in sample_sizes:
    # Random
    samples_random = np.random.rand(num_samples, 6)
    estimated_integral_random = monte_carlo_integration(function, samples_random, sequence = 'random')
    estimated_integrals_random.append(estimated_integral_random)

    # Halton
    samples_halton = qmc.Sobol(6).random(num_samples)
    estimated_integral_halton = monte_carlo_integration(function, samples_halton, sequence = 'halton')
    estimated_integrals_halton.append(estimated_integral_halton)

    # Latin Hypercube Sampling (LHS)
    engine = qmc.LatinHypercube(d = 6)
    samples_lhs = engine.random(n = num_samples)
    estimated_integral_lhs = monte_carlo_integration(function, samples_lhs, sequence = 'lhs')
    estimated_integrals_lhs.append(estimated_integral_lhs)

# Plot the results

plt.plot(sample_sizes, estimated_integrals_random, marker = 'o', label = 'Random')
plt.plot(sample_sizes, estimated_integrals_halton, marker = 'o', label = 'Halton')
plt.plot(sample_sizes, estimated_integrals_lhs, marker = 'o', label = 'LHS')
plt.xlabel('Sample Size')
plt.ylabel('Estimated Integral Value')
plt.title('Monte Carlo Integration: Estimated Integral vs Sample Size')
plt.legend()
plt.grid(True)
plt.show()

### 2.4 Application of nquad()

import time # Timer
t1 = time.perf_counter()

import numpy as np
from scipy.integrate import nquad

def integrand(x1, x2, x3, x4, x5, x6):
    return np.sin(np.pi/2 * np.exp((x1+x2+x3)/3) * np.exp((x4+x5+x6)/3))

integral, error = nquad(integrand, [(0, 1)]*6)

print("Numerical solution: ", integral)
print("Error: ", error)

t2 = time.perf_counter()
print('time taken to run:',t2-t1)